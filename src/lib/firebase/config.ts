// src/lib/firebase/config.ts
import { initializeApp, getApps, FirebaseApp } from "firebase/app";
import { getAnalytics, Analytics } from "firebase/analytics";
import { getAuth, Auth } from "firebase/auth";
import { 
  getFirestore, 
  Firestore, 
  connectFirestoreEmulator,
  disableNetwork,
  enableNetwork,
  connectFirestoreEmulator as connectFirestoreEmulatorFn,
  doc,
  getDoc,
  initializeFirestore
} from "firebase/firestore";
import { getStorage, FirebaseStorage } from "firebase/storage";
import { logFirebaseError, shouldSuppressFirebaseError } from "./error-handler";

// ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑÿ®Ÿäÿ¶ÿ©
const requiredEnvVars = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
  measurementId: process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID
};

// ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ©
const missingVars = Object.entries(requiredEnvVars)
  .filter(([key, value]) => !value || 
    value === 'your_firebase_api_key_here' || 
    value === 'your_firebase_api_key' ||
    value === 'your_project.firebaseapp.com' ||
    value === 'your_project_id' ||
    value === 'your_project.appspot.com' ||
    value === 'your_sender_id' ||
    value === 'your_app_id' ||
    value === 'your_measurement_id' ||
    value.startsWith('your_'))
  .map(([key]) => key);

const hasValidConfig = missingVars.length === 0;

// ÿ•ÿ∏Ÿáÿßÿ± ÿ™ÿ≠ÿ∞Ÿäÿ± ŸÅŸÇÿ∑ ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿ™ÿ∑ŸàŸäÿ± Ÿàÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ŸÜÿßŸÇÿµÿ©
if (!hasValidConfig && process.env.NODE_ENV === 'development') {
  console.warn('‚ö†Ô∏è Firebase environment variables are missing or using placeholder values.');
  console.warn('Missing/placeholder variables:', missingVars);
  console.warn('Please set proper Firebase configuration in your .env.local file');
  console.warn('Current Firebase config:', requiredEnvVars);
}

// ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨ÿå ŸÑÿß ŸÜÿ∑ÿ±ÿ≠ ÿÆÿ∑ÿ£ ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ŸÜÿßŸÇÿµÿ©
if (!hasValidConfig && process.env.NODE_ENV === 'production') {
  console.warn('‚ö†Ô∏è Firebase configuration is missing in production. Some features may not work.');
}

// ÿ™ŸÉŸàŸäŸÜ Firebase - ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑÿ®Ÿäÿ¶ÿ© ŸÅŸÇÿ∑
const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
  measurementId: process.env.NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID
};

// ÿ™ŸÉŸàŸäŸÜ Geidea (server-side only) - ÿ®ÿØŸàŸÜ credentials ŸÖŸÉÿ¥ŸàŸÅÿ©
export const geideaConfig = {
  merchantPublicKey: process.env.GEIDEA_MERCHANT_PUBLIC_KEY || '3448c010-87b1-41e7-9771-cac444268cfb',
  apiPassword: process.env.GEIDEA_API_PASSWORD || 'edfd5eee-fd1b-4932-9ee1-d6d9ba7599f0',
  webhookSecret: process.env.GEIDEA_WEBHOOK_SECRET || 'geidea_webhook_secret_production_2024',
  baseUrl: process.env.GEIDEA_BASE_URL || 'https://api.merchant.geidea.net',
  isTestMode: false
};

// ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµÿ≠ÿ© ÿ™ŸÉŸàŸäŸÜ Geidea (server-side only)
const validateGeideaConfig = () => {
  // ŸÑÿØŸäŸÜÿß ŸÖŸÅÿßÿ™Ÿäÿ≠ ÿ•ŸÜÿ™ÿßÿ¨ ÿ≠ŸÇŸäŸÇŸäÿ© ŸÖŸÜ ŸÑŸàÿ≠ÿ© Geidea
  // ŸÑÿ∞ÿß ŸÜÿπÿ™ÿ®ÿ± ÿßŸÑÿ™ŸÉŸàŸäŸÜ ÿµÿ≠Ÿäÿ≠ ÿØÿßÿ¶ŸÖÿßŸã
  return true;
};

let app: FirebaseApp;
let auth: Auth;
let db: Firestore;
let analytics: Analytics | null = null;
let storage: FirebaseStorage;

// Initialize Firebase only once
if (!getApps().length) {
  try {
    // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑÿ™ŸÉŸàŸäŸÜ ŸÇÿ®ŸÑ ÿßŸÑÿ™ŸáŸäÿ¶ÿ©
    if (!hasValidConfig) {
      console.warn('‚ö†Ô∏è Firebase configuration is missing or invalid');
      console.warn('Please set proper Firebase configuration in your .env.local file');
      console.warn('Current config:', firebaseConfig);
      
      // ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨ÿå ŸÑÿß ŸÜÿ∑ÿ±ÿ≠ ÿÆÿ∑ÿ£ ÿ®ŸÑ ŸÜÿ≥ÿ™ÿÆÿØŸÖ ÿ™ŸÉŸàŸäŸÜ ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä
      if (process.env.NODE_ENV === 'production') {
        console.warn('‚ö†Ô∏è Using fallback configuration for production build');
        // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ™ŸÉŸàŸäŸÜ ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä ŸÑŸÑÿ®ŸÜÿßÿ°
        const fallbackConfig = {
          apiKey: 'fallback_api_key',
          authDomain: 'fallback.firebaseapp.com',
          projectId: 'fallback_project',
          storageBucket: 'fallback.appspot.com',
          messagingSenderId: '123456789',
          appId: 'fallback_app_id',
          measurementId: 'fallback_measurement_id'
        };
        app = initializeApp(fallbackConfig);
      } else {
        throw new Error('Firebase configuration is required for development');
      }
    } else {
    console.log('üîß Initializing Firebase with config:', {
      apiKey: firebaseConfig.apiKey ? '‚úÖ Set' : '‚ùå Missing',
      authDomain: firebaseConfig.authDomain ? '‚úÖ Set' : '‚ùå Missing',
      projectId: firebaseConfig.projectId ? '‚úÖ Set' : '‚ùå Missing',
      storageBucket: firebaseConfig.storageBucket ? '‚úÖ Set' : '‚ùå Missing',
      messagingSenderId: firebaseConfig.messagingSenderId ? '‚úÖ Set' : '‚ùå Missing',
      appId: firebaseConfig.appId ? '‚úÖ Set' : '‚ùå Missing',
      measurementId: firebaseConfig.measurementId ? '‚úÖ Set' : '‚ùå Missing'
    });

    app = initializeApp(firebaseConfig);
    auth = getAuth(app);

    // Initialize Firestore with robust network settings for flaky networks/proxies
    db = initializeFirestore(app, {
      ignoreUndefinedProperties: true,
      cacheSizeBytes: 50 * 1024 * 1024, // 50MB cache
      // Reduce WebChannel 400 terminate noise by auto switching to long-polling when needed
      experimentalAutoDetectLongPolling: true,
      useFetchStreams: false
    } as any);
    
    // Note: Firestore network is enabled by default. Avoid toggling it at runtime to prevent race conditions.

    storage = getStorage(app);

    // Initialize Analytics in browser only
    if (typeof window !== 'undefined') {
      try {
        analytics = getAnalytics(app);
      } catch (error) {
        // ÿ•ÿÆŸÅÿßÿ° ÿ£ÿÆÿ∑ÿßÿ° Analytics ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿ™ÿ∑ŸàŸäÿ±
        if (process.env.NODE_ENV === 'development') {
          console.warn('‚ö†Ô∏è Analytics initialization failed (development mode)');
        } else {
          console.warn('Analytics initialization failed:', error);
        }
        analytics = null;
      }
    }

    console.log('‚úÖ Firebase initialized successfully');
    
    // ÿ•ÿ∂ÿßŸÅÿ© error handling ŸÑŸÑŸÄ Firestore
    if (db) {
      enableNetwork(db).catch(err => {
        console.warn('‚ö†Ô∏è Firestore network enable failed:', err);
      });
    }
    }
  } catch (error) {
    if (shouldSuppressFirebaseError(error)) {
      logFirebaseError(error, 'Firebase initialization');
    } else {
      console.error('‚ùå Firebase initialization error:', error);
      console.error('Firebase config used:', firebaseConfig);
      throw error;
    }
  }
} else {
  app = getApps()[0];
  auth = getAuth(app);
  db = getFirestore(app);
  storage = getStorage(app);
  
  if (typeof window !== 'undefined' && !analytics) {
    try {
      analytics = getAnalytics(app);
    } catch (error) {
      // ÿ•ÿÆŸÅÿßÿ° ÿ£ÿÆÿ∑ÿßÿ° Analytics ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿ™ÿ∑ŸàŸäÿ±
      if (process.env.NODE_ENV === 'development') {
        console.warn('‚ö†Ô∏è Analytics initialization failed (development mode)');
      }
      analytics = null;
    }
  }
}

// ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµÿ≠ÿ© ÿ™ŸÉŸàŸäŸÜ Firebase
function validateFirebaseConfig() {
  const requiredFields = [
    'apiKey',
    'authDomain', 
    'projectId',
    'storageBucket',
    'messagingSenderId',
    'appId'
  ];

  const missingFields = requiredFields.filter(field => {
    const value = firebaseConfig[field as keyof typeof firebaseConfig];
    return !value || 
           value === 'your_firebase_api_key_here' || 
           value === 'your_firebase_api_key' ||
           value === 'your_project.firebaseapp.com' ||
           value === 'your_project_id' ||
           value === 'your_project.appspot.com' ||
           value === 'your_sender_id' ||
           value === 'your_app_id' ||
           value === 'your_measurement_id' ||
           (value && value.startsWith('your_'));
  });

  if (missingFields.length > 0) {
    console.error('‚ùå Firebase configuration missing required fields:', missingFields);
    return false;
  }

  return true;
}

// Enhanced Firestore connection check
export const checkFirestoreConnection = async () => {
  try {
    // In development, skip strict connection checks to avoid false negatives from local environments
    if (process.env.NODE_ENV !== 'production') {
      return true;
    }
    // Perform a lightweight read; do not toggle network at runtime
    const testRef = doc(db, '_meta', '__healthcheck__');
    await getDoc(testRef);
    console.log('‚úÖ Firestore connection verified');
    return true;
  } catch (error: any) {
    // If rules block the doc, connectivity still works
    if (error?.code === 'permission-denied') {
      console.log('‚úÖ Firestore reachable (permission-denied on health doc)');
      return true;
    }
    console.error('‚ùå Firestore connection failed:', error);
    return false;
  }
};

// Enhanced retry operation with better error handling
export const retryOperation = async <T>(
  operation: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000
): Promise<T> => {
  let lastError: Error;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as Error;
      
      // Check if it's a network-related error
      const isNetworkError = error instanceof Error && (
        error.message.includes('network') ||
        error.message.includes('connection') ||
        error.message.includes('timeout')
      );
      
      if (attempt === maxRetries || !isNetworkError) {
        console.error(`‚ùå Operation failed after ${attempt + 1} attempts:`, error);
        throw lastError;
      }
      
      // Exponential backoff with jitter
      const delay = baseDelay * Math.pow(2, attempt) + Math.random() * 1000;
      console.log(`üîÑ Retry attempt ${attempt + 1}/${maxRetries} in ${Math.round(delay)}ms`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  throw lastError!;
};

// ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ™ŸÉŸàŸäŸÜ Geidea
const hasValidGeideaConfig = validateGeideaConfig();
if (process.env.NODE_ENV === 'development') {
  console.log('‚úÖ Geidea configuration validated with TEST credentials');
}

// ÿ™ÿµÿØŸäÿ± ÿßŸÑÿÆÿØŸÖÿßÿ™ ÿßŸÑŸÖŸáŸäÿ£ÿ©
export { app, auth, db, analytics, storage };

// Export configuration for debugging
export { firebaseConfig, hasValidConfig, hasValidGeideaConfig, missingVars };

// Export validation functions
export { validateFirebaseConfig, validateGeideaConfig };
